{"version":3,"sources":["autocomplete.ts","Omnibox.js","omniboxSearch.js"],"names":["Omnibox","props","console","log","tableId","blockNodeId","closeNodeId","inputId","linkList","_injectOmnibox","omniboxBlock","document","getElementById","omniboxClose","omniboxInput","obAlt","obCtrl","omnibox","addEventListener","event","altKey","ctrlKey","key","toLowerCase","keyCode","docLocation","location","toString","showOmnibox","hideOmnibox","container","createElement","classList","add","id","input","type","close","appendChild","body","length","listItems","parentNode","querySelectorAll","forEach","node","findAll","mainLink","querySelector","push","label","textContent","value","href","split","innerLinks","innerNode","prepareList","remove","omniboxRef","className","debounceWaitMs","emptyMsg","render","item","listItem","fetch","text","update","filter","n","includes","sort","a","b","onSelect","scrollIntoView","focus","removeEventListener","destroy"],"mappings":"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","file":"omniboxSearch.js","sourceRoot":"..","sourcesContent":[" /*\r\n  * https://github.com/kraaden/autocomplete\r\n  * Copyright (c) 2016 Denys Krasnoshchok\r\n  * MIT License\r\n  */\r\n\r\nexport const enum EventTrigger {\r\n    Keyboard = 0,\r\n    Focus = 1\r\n}\r\n\r\nexport interface AutocompleteItem {\r\n    label?: string;\r\n    group?: string;\r\n}\r\n\r\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\r\n    input: HTMLInputElement;\r\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className?: string;\r\n    minLength?: number;\r\n    emptyMsg?: string;\r\n    onSelect: (item: T, input: HTMLInputElement) => void;\r\n    /**\r\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\r\n     */\r\n    showOnFocus?: boolean;\r\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\r\n    debounceWaitMs?: number;\r\n    /**\r\n     * Callback for additional autocomplete customization\r\n     * @param {HTMLInputElement} input - input box associated with autocomplete\r\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\r\n     * @param {HTMLDivElement} container - container with suggestions\r\n     * @param {number} maxHeight - max height that can be used by autocomplete\r\n     */\r\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n    /**\r\n     * Prevents automatic form submit when ENTER is pressed\r\n     */\r\n    preventSubmit?: boolean;\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n    destroy: () => void;\r\n}\r\n\r\nconst enum Keys {\r\n    Enter = 13,\r\n    Esc = 27,\r\n    Up = 38,\r\n    Down = 40,\r\n    Left = 37,\r\n    Right = 39,\r\n    Shift = 16,\r\n    Ctrl = 17,\r\n    Alt = 18,\r\n    CapsLock = 20,\r\n    WindowsKey = 91,\r\n    Tab = 9,\r\n    F1 = 112,\r\n    F12 = 123\r\n}\r\n\r\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\r\n\r\n    // just an alias to minimize JS file size\r\n    const doc = document;\r\n\r\n    const container: HTMLDivElement = doc.createElement(\"div\");\r\n    const containerStyle = container.style;\r\n    const userAgent = navigator.userAgent;\r\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\r\n    const debounceWaitMs = settings.debounceWaitMs || 0;\r\n    const preventSubmit = settings.preventSubmit || false;\r\n    \r\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\r\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\r\n    \r\n    let items: T[] = [];\r\n    let inputValue = \"\";\r\n    let minLen = 2;\r\n    const showOnFocus = settings.showOnFocus;\r\n    let selected: T | undefined;\r\n    let keypressCounter = 0;\r\n    let debounceTimer : number | undefined;\r\n\r\n    if (settings.minLength !== undefined) {\r\n        minLen = settings.minLength;\r\n    }\r\n\r\n    if (!settings.input) {\r\n        throw new Error(\"input undefined\");\r\n    }\r\n\r\n    const input: HTMLInputElement = settings.input;\r\n\r\n    container.className = \"autocomplete \" + (settings.className || \"\");\r\n\r\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\r\n    containerStyle.position = \"absolute\";\r\n\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach(): void {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer(): void {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach(): void {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed(): boolean {\r\n        return !!container.parentNode;\r\n    }\r\n\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear(): void {\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n        \r\n        items = [];\r\n        inputValue = \"\";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition(): void {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        containerStyle.height = \"auto\";\r\n        containerStyle.width = input.offsetWidth + \"px\";\r\n\r\n        let maxHeight = 0;\r\n        let inputRect: ClientRect | DOMRect | undefined;\r\n\r\n        function calc() {\r\n            const docEl = doc.documentElement as HTMLElement;\r\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\r\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\r\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\r\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\r\n\r\n            inputRect = input.getBoundingClientRect();\r\n        \r\n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\r\n            const left = inputRect.left + scrollLeft - clientLeft;\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.left = left + \"px\";\r\n    \r\n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\r\n    \r\n            if (maxHeight < 0) {\r\n                maxHeight = 0;\r\n            }\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.bottom = \"\";\r\n            containerStyle.left = left + \"px\";\r\n            containerStyle.maxHeight = maxHeight + \"px\";\r\n        }\r\n\r\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\r\n        calc();\r\n        calc();\r\n\r\n        if (settings.customize && inputRect) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update(): void {\r\n        \r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n\r\n        // function for rendering autocomplete suggestions\r\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\r\n            const itemElement = doc.createElement(\"div\");\r\n            itemElement.textContent = item.label || \"\";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n\r\n        // function to render autocomplete groups\r\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\r\n            const groupDiv = doc.createElement(\"div\");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n\r\n        const fragment = doc.createDocumentFragment();\r\n        let prevGroup = \"#9?$\";\r\n\r\n        items.forEach(function(item: T): void {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                const groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += \" group\";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            const div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\r\n                    settings.onSelect(item, input);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += \" selected\";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1) {\r\n            if (settings.emptyMsg) {\r\n                const empty = doc.createElement(\"div\");\r\n                empty.className = \"empty\";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n            } else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n\r\n        attach();\r\n        updatePosition();\r\n\r\n        updateScroll();\r\n    }\r\n\r\n    function updateIfDisplayed(): void {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n\r\n    function resizeEventHandler(): void {\r\n        updateIfDisplayed();\r\n    }\r\n\r\n    function scrollEventHandler(e: Event): void {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        } else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    function keyupEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\r\n        for (const key of ignore) {\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (keyCode >= Keys.F1 && keyCode <= Keys.F12) {\r\n            return;\r\n        }\r\n\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === Keys.Down && containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        startFetch(EventTrigger.Keyboard);\r\n    }\r\n\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll(): void {\r\n        const elements = container.getElementsByClassName(\"selected\");\r\n        if (elements.length > 0) {\r\n            let element = elements[0] as HTMLDivElement;\r\n            \r\n            // make group visible\r\n            const previous = element.previousElementSibling as HTMLDivElement;\r\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            } else {\r\n                const selectBottom = element.offsetTop + element.offsetHeight;\r\n                const containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else {\r\n            if (selected === items[0]) {\r\n                selected = items[items.length - 1];\r\n            } else {\r\n                for (let i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (let i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function keydownEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\r\n            const containerIsDisplayed = containerDisplayed();\r\n\r\n            if (keyCode === Keys.Esc) {\r\n                clear();\r\n            } else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === Keys.Up\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (keyCode === Keys.Enter) {\r\n            if (selected) {\r\n                settings.onSelect(selected, input);\r\n                clear();\r\n            }\r\n    \r\n            if (preventSubmit) {\r\n                ev.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    function focusEventHandler(): void {\r\n        if (showOnFocus) {\r\n            startFetch(EventTrigger.Focus);\r\n        }\r\n    }\r\n\r\n    function startFetch(trigger: EventTrigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        const savedKeypressCounter = ++keypressCounter;\r\n\r\n        const val = input.value;\r\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function(): void {\r\n                settings.fetch(val, function(elements: T[] | false): void {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                }, EventTrigger.Keyboard);\r\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\r\n        } else {\r\n            clear();\r\n        }\r\n    }\r\n\r\n    function blurEventHandler(): void {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(() => {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\r\n    container.addEventListener(\"mousedown\", function(evt: Event) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n    });\r\n\r\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\r\n    container.addEventListener(\"focus\", () => input.focus());\r\n\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy(): void {\r\n        input.removeEventListener(\"focus\", focusEventHandler);\r\n        input.removeEventListener(\"keydown\", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(\"blur\", blurEventHandler);\r\n        window.removeEventListener(\"resize\", resizeEventHandler);\r\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n    }\r\n\r\n    // setup event handlers\r\n    input.addEventListener(\"keydown\", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(\"blur\", blurEventHandler);\r\n    input.addEventListener(\"focus\", focusEventHandler);\r\n    window.addEventListener(\"resize\", resizeEventHandler);\r\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\r\n\r\n    return {\r\n        destroy\r\n    };\r\n}\r\n","import autocomplete from \"autocompleter\";\nimport \"./omnibox.sass\";\n\nclass Omnibox {\n  constructor(props) {\n    console.log({ props });\n    const { tableId, blockNodeId, closeNodeId, inputId } = props;\n    this.tableId = tableId;\n    this.linkList = [];\n    this.closeNodeId = closeNodeId;\n    this.blockNodeId = blockNodeId;\n    this.inputId = inputId;\n\n    this._injectOmnibox();\n\n    this.omniboxBlock = document.getElementById(blockNodeId);\n    this.omniboxClose = document.getElementById(closeNodeId);\n    this.omniboxInput = document.getElementById(inputId);\n\n    this.obAlt = false;\n    this.obCtrl = false;\n\n    console.log({ omnibox: this });\n\n    // Add event listeners\n    document.addEventListener(\"keydown\", event => {\n      if (event.altKey) {\n        this.obAlt = true;\n      }\n      if (event.ctrlKey) {\n        this.obCtrl = true;\n      }\n\n      if (event.key.toLowerCase() === \"f\" || event.keyCode === 70) {\n        const docLocation =\n          location.toString() === \"https://docs.onflow.org/docs/cadence\";\n        if (this.obCtrl && this.obAlt && docLocation) {\n          this.showOmnibox();\n        }\n      }\n\n      if (event.key === \"Escape\") {\n        this.hideOmnibox();\n      }\n    });\n    document.addEventListener(\"keyup\", event => {\n      if (event.altKey) {\n        this.obAlt = false;\n      }\n      if (event.ctrlKey) {\n        this.obCtrl = false;\n      }\n    });\n  }\n\n  _injectOmnibox() {\n    const container = document.createElement(\"div\");\n    container.classList.add(\"omnibox-container\");\n    container.classList.add(\"omnibox-container__hidden\");\n    container.id = this.blockNodeId;\n\n    const input = document.createElement(\"input\");\n    input.type = \"text\";\n    input.id = this.inputId;\n\n    const close = document.createElement(\"div\");\n    close.classList.add(this.closeNodeId);\n    close.id = this.closeNodeId;\n\n    container.appendChild(input);\n    container.appendChild(close);\n\n    document.body.appendChild(container);\n  }\n\n  prepareList() {\n    if (this.linkList.length === 0) {\n      const listItems = document.getElementById(this.tableId).parentNode;\n      const findAll = node => {\n        const mainLink = node.querySelector(\":scope p a, :scope a\");\n        if (mainLink) {\n          this.linkList.push({\n            label: mainLink.textContent,\n            value: mainLink.href.split(\"#\")[1]\n          });\n        }\n\n        const innerLinks = node.querySelectorAll(\":scope > ul > li\");\n        if (innerLinks.length > 0) {\n          innerLinks.forEach(innerNode => findAll(innerNode));\n        }\n      };\n\n      listItems\n        .querySelectorAll(\":scope > ul > li\")\n        .forEach(node => findAll(node));\n    }\n  }\n\n  showOmnibox() {\n    if (this.linkList.length === 0) {\n      this.prepareList();\n    }\n    this.omniboxClose.addEventListener(\"click\", this.hideOmnibox);\n    this.omniboxBlock.classList.remove(\"omnibox-container__hidden\");\n    this.omniboxRef = autocomplete({\n      input: this.omniboxInput,\n      className: \"omnibox\",\n      debounceWaitMs: 50,\n      emptyMsg: \"Nothing found 😟\",\n      render: function(item) {\n        const listItem = document.createElement(\"div\");\n        listItem.textContent = item.label;\n        listItem.classList.add(\"omnibox-item\");\n        return listItem;\n      },\n      fetch: (text, update) => {\n        text = text.toLowerCase();\n        let suggestions = this.linkList\n          .filter(n => n.label.toLowerCase().includes(text))\n          .sort((a, b) => a > b);\n        update(suggestions);\n      },\n      onSelect: item => {\n        // this.omniboxInput.value = item.label;\n        console.log(item.value);\n        const node = document.getElementById(item.value);\n        if (node) {\n          node.scrollIntoView();\n        }\n        this.hideOmnibox();\n      }\n    });\n    this.omniboxInput.focus();\n  }\n\n  hideOmnibox() {\n    this.omniboxInput.value = \"\";\n    this.omniboxClose.removeEventListener(\"click\", this.hideOmnibox);\n    this.omniboxBlock.classList.add(\"omnibox-container__hidden\");\n    if (this.omniboxRef) {\n      this.omniboxRef.destroy();\n    }\n  }\n}\nexport default Omnibox;\n","import Omnibox from \"./Omnibox\";\n\nnew Omnibox({\n  tableId: \"table-of-contents\",\n  blockNodeId: \"omnibox-block\",\n  closeNodeId: \"omnibox--close\",\n  inputId: \"omnibox\"\n});\n\nconsole.log(\"Omnibox is ready for your commands, master!\");\n"]}